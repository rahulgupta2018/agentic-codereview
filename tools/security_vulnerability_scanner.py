"""
Security Vulnerability Scanner Tool Implementation for ADK Code Review System.

This tool provides comprehensive security vulnerability detection and OWASP Top 10 analysis.
"""

import time
import re
import logging  
import sys  
from pathlib import Path
from typing import Dict, Any, List, Optional

from google.adk.tools.tool_context import ToolContext
from tools.sast_rules_loader import load_sast_rules, DEFAULT_LANGUAGE_PRIORITY

# Setup logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

SAST_RULES_DIR = Path(__file__).resolve().parent.parent / "config" / "knowledge_base" / "security_controls" / "sast_rules"
# Adjust if your repo root differs; since you already set project_root in orchestrator, you can also pass it via state.

def _apply_sast_rules_to_code(code: str, rules: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    MVP rule application: scans the combined code blob with regex patterns.
    Later you can evolve this to scan per-file using tool_context.state["files"] or code_by_path.
    """
    findings: List[Dict[str, Any]] = []
    if not code or not rules:
        return findings

    for rule in rules:
        if not isinstance(rule, dict) or not rule.get("enabled", True):
            continue

        det = rule.get("detection", {}) or {}
        patterns = det.get("patterns", []) or []
        allowlist_patterns = det.get("allowlist_patterns", []) or []

        for p in patterns:
            rx = (p or {}).get("regex")
            if not rx:
                continue

            # Find matches
            for m in re.finditer(rx, code, flags=re.IGNORECASE):
                snippet = m.group(0)
                # Basic allowlist suppression (if any allowlist matches the snippet, skip)
                suppressed = False
                for ap in allowlist_patterns:
                    ap_rx = (ap or {}).get("regex")
                    if ap_rx and re.search(ap_rx, snippet, flags=re.IGNORECASE):
                        suppressed = True
                        break
                if suppressed:
                    continue

                findings.append({
                    "type": "sast_rule_match",
                    "rule_id": rule.get("id"),
                    "title": rule.get("title"),
                    "description": rule.get("description"),
                    "category": rule.get("category"),
                    "severity": rule.get("severity", "low"),
                    "confidence": rule.get("confidence", 0.5),
                    "cwe": rule.get("cwe", []),
                    "owasp_top_10_2021": rule.get("owasp_top_10_2021", []),
                    "pattern_name": (p or {}).get("name"),
                    "line": code[:m.start()].count("\n") + 1,
                    "code_snippet": snippet[:200],
                })

    return findings


def scan_security_vulnerabilities(tool_context: ToolContext, code: str = "") -> Dict[str, Any]:
    """
    Comprehensive security vulnerability scanner.

    - Loads SAST rule packs (generic + detected languages) from YAML
    - Runs rule-based regex scanning (MVP)
    - Runs existing OWASP Top 10 heuristic scanners
    - Returns structured result with evidence + summary
    - Stores tool output in state under "security_scan_result" (does NOT clobber agent output_key)

    Args:
        tool_context: ADK ToolContext containing session state
        code: Optional code override (fallback). Prefer tool_context.state["code"].

    Returns:
        dict: Security scan results
    """
    execution_start = time.time()

    try:
        # Prefer state; fallback to passed param; fallback to tool_context.parameters if present
        code_blob = tool_context.state.get("code", "") or code or ""
        language = tool_context.state.get("language", "python")
        file_path = tool_context.state.get("file_path", "unknown")

        if not code_blob and hasattr(tool_context, "parameters"):
            params = getattr(tool_context, "parameters", {}) or {}
            code_blob = params.get("code", "") or ""
            language = params.get("language", language)
            file_path = params.get("file_path", file_path)

        if not code_blob:
            return {
                "status": "error",
                "tool_name": "scan_security_vulnerabilities",
                "error_message": "No code provided for security analysis",
            }

        # Determine languages for rule loading (adapter sets state["languages"])
        langs = tool_context.state.get("languages", []) or []
        if not langs:
            lang = tool_context.state.get("language")
            # Avoid trying to load "multi.yaml"
            if lang and lang != "multi":
                langs = [lang]

        # Load SAST rules
        load_result = load_sast_rules(
            SAST_RULES_DIR,
            detected_languages=langs,
            language_priority=DEFAULT_LANGUAGE_PRIORITY,
            include_generic=True,
            include_schema_file=False,  # can enable later
        )

        if load_result.warnings:
            logger.info("SAST rules loader warnings: %s", load_result.warnings)
        logger.info("Loaded SAST rule files: %s", load_result.loaded_files)
        logger.info("Loaded SAST rules: %d", len(load_result.rules))

        rules = load_result.rules

        # Run rule-based findings (MVP: combined blob)
        sast_findings = _apply_sast_rules_to_code(code_blob, rules)

        # Ensure SAST findings have a file_path fallback (combined PR scans often lack per-file attribution)
        if isinstance(sast_findings, list):
            for f in sast_findings:
                if isinstance(f, dict) and not f.get("file_path"):
                    f["file_path"] = file_path

        # Run OWASP heuristic scans
        owasp = {
            "injection_vulnerabilities": _scan_injection_vulnerabilities(code_blob, language),
            "broken_authentication": _scan_authentication_issues(code_blob, language),
            "sensitive_data_exposure": _scan_data_exposure(code_blob, language),
            "xml_external_entities": _scan_xxe_vulnerabilities(code_blob, language),
            "broken_access_control": _scan_access_control(code_blob, language),
            "security_misconfiguration": _scan_security_config(code_blob, language),
            "cross_site_scripting": _scan_xss_vulnerabilities(code_blob, language),
            "insecure_deserialization": _scan_deserialization(code_blob, language),
            "vulnerable_components": _scan_vulnerable_components(code_blob, language),
            "insufficient_logging": _scan_logging_issues(code_blob, language),
        }

        owasp_count = 0
        for v in owasp.values():
            if isinstance(v, list):
                owasp_count += len(v)

        logger.info(
            "Security scan findings: OWASP=%d, SAST=%d",
            owasp_count,
            len(sast_findings) if isinstance(sast_findings, list) else 0,
        )

        # Summarize severities across both sources
        summary = {
            "total_vulnerabilities": 0,
            "critical_vulnerabilities": 0,
            "high_vulnerabilities": 0,
            "medium_vulnerabilities": 0,
            "low_vulnerabilities": 0,
        }

        all_findings: List[Dict[str, Any]] = []

        # OWASP findings
        for vulns in owasp.values():
            if isinstance(vulns, list):
                all_findings.extend(vulns)

        # SAST findings
        if isinstance(sast_findings, list):
            all_findings.extend(sast_findings)

        for finding in all_findings:
            if not isinstance(finding, dict):
                continue
            summary["total_vulnerabilities"] += 1
            sev = (finding.get("severity") or "low").lower()
            if sev not in ("critical", "high", "medium", "low"):
                sev = "low"
            summary[f"{sev}_vulnerabilities"] += 1

        security_result: Dict[str, Any] = {
            "status": "success",
            "tool_name": "scan_security_vulnerabilities",
            "file_path": file_path,
            "language": language,
            "languages_detected": langs,
            "analysis_type": "security_vulnerability_scan",
            "sast_rules": {
                "rules_loaded": len(rules),
                "files_loaded": load_result.loaded_files,
                "warnings": load_result.warnings,
                "findings": sast_findings,
            },
            "owasp_top_10_analysis": owasp,
            "vulnerability_summary": summary,
            "risk_assessment": _assess_security_risk(
                code_blob, 
                language, 
                vulnerabilities=all_findings,
                ),
            "compliance_check": _check_security_compliance(code_blob, language),
            "recommendations": _generate_security_recommendations(
                code_blob,
                language,
                vulnerabilities=all_findings,
            ),
            "timestamp": time.time(),
        }

        security_result["execution_time_seconds"] = time.time() - execution_start

        # âœ… IMPORTANT: avoid clobbering the agent's "security_analysis" output_key
        tool_context.state["security_scan_result"] = security_result

        # Update analysis progress
        analysis_progress = tool_context.state.get("analysis_progress", {}) or {}
        analysis_progress["security_scan_completed"] = True
        analysis_progress["security_scan_timestamp"] = time.time()
        tool_context.state["analysis_progress"] = analysis_progress

        return security_result

    except Exception as e:
        error_result = {
            "status": "error",
            "tool_name": "scan_security_vulnerabilities",
            "error_message": str(e),
            "error_type": type(e).__name__,
            "execution_time_seconds": time.time() - execution_start,
        }
        tool_context.state["security_scan_error"] = error_result
        return error_result


def _scan_injection_vulnerabilities(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for injection vulnerabilities (OWASP A03: Injection)."""
    vulnerabilities: List[Dict[str, Any]] = []

    # NOTE:
    # - Avoid flagging parameterized queries as SQL injection.
    # - Focus on concatenation/interpolation passed into execute() or query building.

    sql_patterns = [
        # f-string / interpolation into execute()
        (r"\.execute\(\s*f[\"'].*\b(SELECT|INSERT|UPDATE|DELETE)\b", "Possible SQL injection via f-string in execute()", "high", "CWE-89"),
        (r"\.execute\(\s*[\"'].*\b(SELECT|INSERT|UPDATE|DELETE)\b.*\.format\(", "Possible SQL injection via .format() in execute()", "high", "CWE-89"),
        (r"cursor\.execute\s*\([^)]*\+[^)]*\)", "Possible SQL injection via string concatenation in cursor.execute()", "critical", "CWE-89"),
        (r"WHERE\s+[^=]*=\s*['\"][^'\"]*['\"]\s*\+", "Possible SQL injection via concatenation in WHERE clause", "high", "CWE-89"),
    ]

    for pattern, message, severity, cwe in sql_patterns:
        for match in re.finditer(pattern, code, re.IGNORECASE):
            snippet = match.group(0)
            vulnerabilities.append({
                "type": "injection_vulnerability",
                "subtype": "sql_injection",
                "title": "Potential SQL Injection",
                "description": message,
                "category": "Injection & Unsafe Calls",
                "severity": severity,
                "line": code[:match.start()].count("\n") + 1,
                "code_snippet": snippet[:200],
                "cwe": [cwe],
                "owasp_top_10_2021": ["a03_injection"],
            })

    nosql_patterns = [
        (r"\$where\s*:", "Possible NoSQL injection via $where operator", "high", "CWE-943"),
        (r"eval\s*\([^)]*user", "Possible NoSQL injection/code execution via eval(user*)", "critical", "CWE-94"),
    ]

    for pattern, message, severity, cwe in nosql_patterns:
        for match in re.finditer(pattern, code, re.IGNORECASE):
            snippet = match.group(0)
            vulnerabilities.append({
                "type": "injection_vulnerability",
                "subtype": "nosql_injection",
                "title": "Potential NoSQL Injection / Unsafe Eval",
                "description": message,
                "category": "Injection & Unsafe Calls",
                "severity": severity,
                "line": code[:match.start()].count("\n") + 1,
                "code_snippet": snippet[:200],
                "cwe": [cwe],
                "owasp_top_10_2021": ["a03_injection"],
            })

    return vulnerabilities


def _scan_authentication_issues(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for broken authentication / auth implementation weaknesses (OWASP)."""
    vulnerabilities: List[Dict[str, Any]] = []

    auth_patterns = [
        # Hardcoded credential checks
        (r"password\s*==\s*[\"'][^\"']+[\"']",
         "Hardcoded password comparison detected (possible hardcoded credential logic).",
         "high",
         ["CWE-798"],
         ["a02_cryptographic_failures"]),

        # Direct session mutation (framework-specific, lower signal)
        (r"session\[\s*[\"']user[\"']\s*\]\s*=",
         "Direct session user assignment detected; ensure authentication and authorization checks cannot be bypassed.",
         "medium",
         ["CWE-287"],
         ["a01_broken_access_control"]),

        # JWT verification disabled / authenticity not verified (pattern may vary by library)
        (r"jwt\.decode\([^,]*,\s*verify\s*=\s*False",
         "JWT verification appears disabled; this can allow forged tokens to be accepted.",
         "critical",
         ["CWE-345"],
         ["a01_broken_access_control"]),

        # Weak password hashing
        (r"\bmd5\s*\([^)]*password",
         "Weak password hashing detected (MD5). Use a strong password hashing function (bcrypt/scrypt/Argon2).",
         "high",
         ["CWE-327"],
         ["a02_cryptographic_failures"]),
    ]

    for pattern, message, severity, cwes, owasp_tags in auth_patterns:
        for match in re.finditer(pattern, code, re.IGNORECASE):
            snippet = match.group(0)
            vulnerabilities.append({
                "type": "authentication_vulnerability",
                "title": "Authentication / Token Handling Issue",
                "description": message,
                "category": "Authentication & Authorization",
                "severity": severity,
                "line": code[:match.start()].count("\n") + 1,
                "code_snippet": snippet[:200],
                "cwe": cwes,
                "owasp_top_10_2021": owasp_tags,
            })

    return vulnerabilities


def _scan_data_exposure(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for sensitive data exposure / secrets leakage patterns (OWASP)."""
    vulnerabilities: List[Dict[str, Any]] = []

    exposure_patterns = [
        (r"print\([^)]*password[^)]*\)",
         "Password printed to output/logs; this can leak credentials.",
         "high",
         ["CWE-532"],
         ["a02_cryptographic_failures"]),

        (r"log\.[^(]*\([^)]*secret[^)]*\)",
         "Secret appears to be logged; logging secrets can cause credential leakage.",
         "medium",
         ["CWE-532"],
         ["a02_cryptographic_failures"]),

        (r"\bapi_key\s*=\s*[\"'][^\"']+[\"']",
         "Hardcoded API key detected; move to environment variables/secret manager and rotate if exposed.",
         "high",
         ["CWE-798"],
         ["a02_cryptographic_failures"]),

        (r"\bprivate_key\s*=\s*[\"']",
         "Hardcoded private key material detected; this is extremely sensitive and should never be committed.",
         "critical",
         ["CWE-798"],
         ["a02_cryptographic_failures"]),
    ]

    for pattern, message, severity, cwes, owasp_tags in exposure_patterns:
        for match in re.finditer(pattern, code, re.IGNORECASE):
            snippet = match.group(0)
            vulnerabilities.append({
                "type": "data_exposure_vulnerability",
                "title": "Sensitive Data Exposure / Secret Leak",
                "description": message,
                "category": "Secrets Management",
                "severity": severity,
                "line": code[:match.start()].count("\n") + 1,
                "code_snippet": snippet[:200],
                "cwe": cwes,
                "owasp_top_10_2021": owasp_tags,
            })

    return vulnerabilities


def _scan_xxe_vulnerabilities(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for XML External Entity vulnerabilities (OWASP)."""
    vulnerabilities: List[Dict[str, Any]] = []

    xxe_patterns = [
        (
            r"XMLParser\([^)]*resolve_entities\s*=\s*True",
            "XML parser enables entity resolution (resolve_entities=True), which can enable XXE if parsing untrusted XML.",
            "high",
            ["CWE-611"],
            ["a05_security_misconfiguration"],  # closest OWASP 2021 bucket
        ),
        (
            r"\betree\.parse\([^)]*\)",
            "Potentially unsafe XML parsing detected (etree.parse). Ensure external entities and network access are disabled for untrusted XML.",
            "medium",
            ["CWE-611"],
            ["a05_security_misconfiguration"],
        ),
    ]

    for pattern, message, severity, cwes, owasp_tags in xxe_patterns:
        for match in re.finditer(pattern, code, re.IGNORECASE):
            snippet = match.group(0)
            vulnerabilities.append({
                "type": "xxe_vulnerability",
                "title": "Potential XXE / Unsafe XML Parsing",
                "description": message,
                "category": "Data Protection",
                "severity": severity,
                "line": code[:match.start()].count("\n") + 1,
                "code_snippet": snippet[:200],
                "cwe": cwes,
                "owasp_top_10_2021": owasp_tags,
            })

    return vulnerabilities


def _scan_access_control(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for broken access control / unsafe command execution patterns (OWASP)."""
    vulnerabilities: List[Dict[str, Any]] = []

    access_patterns = [
        # NOTE: This is a heuristic and can be noisy. We keep it but it should be medium severity and rely on enrichment.
        (
            r"@app\.route\([^)]*\)\s*\n\s*def\s+\w+\s*\([^)]*\)\s*:",
            "Route handler detected. Verify this endpoint enforces authentication/authorization where required.",
            "medium",
            ["CWE-284"],
            ["a01_broken_access_control"],
        ),
        (
            r"\bos\.system\([^)]*user",
            "Command execution uses a value that appears user-controlled (os.system). This can allow command injection.",
            "critical",
            ["CWE-78"],
            ["a03_injection"],
        ),
        (
            r"\bsubprocess\.\w+\([^)]*user",
            "Subprocess execution uses a value that appears user-controlled. This can allow command injection if inputs are not validated/escaped.",
            "high",
            ["CWE-78"],
            ["a03_injection"],
        ),
    ]

    for pattern, message, severity, cwes, owasp_tags in access_patterns:
        for match in re.finditer(pattern, code, re.IGNORECASE | re.DOTALL):
            snippet = match.group(0)
            vulnerabilities.append({
                "type": "access_control_vulnerability",
                "title": "Access Control / Unsafe Command Execution",
                "description": message,
                "category": "Authentication & Authorization" if "route handler" in message.lower() else "Injection & Unsafe Calls",
                "severity": severity,
                "line": code[:match.start()].count("\n") + 1,
                "code_snippet": snippet[:200],
                "cwe": cwes,
                "owasp_top_10_2021": owasp_tags,
            })

    return vulnerabilities


def _scan_security_config(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for security misconfiguration patterns (OWASP A05)."""
    vulnerabilities: List[Dict[str, Any]] = []

    config_patterns = [
        (
            r"\bDEBUG\s*=\s*True\b",
            "Debug mode appears enabled. Ensure debug is disabled in production deployments.",
            "medium",
            ["CWE-489"],
            ["a05_security_misconfiguration"],
            "Error Handling & Logging",
            "Debug mode enabled",
        ),
        (
            r"(?i)\b(ssl_verify|verify)\s*=\s*False\b",
            "TLS/SSL certificate verification appears disabled. This can enable MITM attacks.",
            "high",
            ["CWE-295"],
            ["a02_cryptographic_failures"],
            "Data Protection",
            "TLS verification disabled",
        ),
        (
            r"(?i)\bCORS\s*\([^)]*origins\s*=\s*\*\b",
            "CORS is configured to allow all origins (*). Restrict origins to known trusted domains.",
            "medium",
            ["CWE-942"],
            ["a05_security_misconfiguration"],
            "Data Protection",
            "Overly permissive CORS",
        ),
        (
            r"(?i)Access-Control-Allow-Origin\s*:\s*\*",
            "Access-Control-Allow-Origin is set to '*'. This is overly permissive for sensitive endpoints.",
            "medium",
            ["CWE-942"],
            ["a05_security_misconfiguration"],
            "Data Protection",
            "Wildcard CORS header",
        ),
    ]

    for pattern, message, severity, cwes, owasp_tags, category, title in config_patterns:
        for match in re.finditer(pattern, code, re.IGNORECASE):
            snippet = match.group(0)
            vulnerabilities.append({
                "type": "security_misconfiguration",
                "title": title,
                "description": message,
                "category": category,
                "severity": severity,
                "line": code[:match.start()].count("\n") + 1,
                "code_snippet": snippet[:200],
                "cwe": cwes,
                "owasp_top_10_2021": owasp_tags,
            })

    return vulnerabilities


def _scan_xss_vulnerabilities(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for Cross-Site Scripting / template injection patterns (OWASP A03)."""
    vulnerabilities: List[Dict[str, Any]] = []

    xss_patterns = [
        (
            r"\binnerHTML\s*=\s*[^;]*\buser\b",
            "Potential XSS: assigning user-controlled data to innerHTML can execute scripts in the browser.",
            "high",
            ["CWE-79"],
            ["a03_injection"],
            "Injection & Unsafe Calls",
            "Potential XSS via innerHTML",
        ),
        (
            r"\bdocument\.write\(\s*[^)]*\buser\b",
            "Potential XSS: document.write with user-controlled content can inject scripts into the DOM.",
            "high",
            ["CWE-79"],
            ["a03_injection"],
            "Injection & Unsafe Calls",
            "Potential XSS via document.write",
        ),
        (
            r"\brender_template_string\(\s*[^)]*\buser\b",
            "Potential server-side template injection: rendering templates from user-controlled input can lead to code execution.",
            "critical",
            ["CWE-94"],
            ["a03_injection"],
            "Injection & Unsafe Calls",
            "Potential server-side template injection",
        ),
    ]

    for pattern, message, severity, cwes, owasp_tags, category, title in xss_patterns:
        for match in re.finditer(pattern, code, re.IGNORECASE):
            snippet = match.group(0)
            vulnerabilities.append({
                "type": "xss_vulnerability",
                "title": title,
                "description": message,
                "category": category,
                "severity": severity,
                "line": code[:match.start()].count("\n") + 1,
                "code_snippet": snippet[:200],
                "cwe": cwes,
                "owasp_top_10_2021": owasp_tags,
            })

    return vulnerabilities


def _scan_deserialization(code: str, language: str) -> List[Dict[str, Any]]:
    """Scan for insecure deserialization / unsafe dynamic execution patterns (OWASP)."""
    vulnerabilities: List[Dict[str, Any]] = []

    deser_patterns = [
        (
            r"\bpickle\.loads?\(",
            "Use of pickle deserialization detected. Unpickling untrusted data can lead to remote code execution.",
            "critical",
            ["CWE-502"],
            ["a08_software_and_data_integrity_failures"],  # OWASP 2021 bucket closest to deserialization/supply chain integrity
            "Injection & Unsafe Calls",
            "Unsafe deserialization via pickle",
        ),
        (
            r"\byaml\.load\(",
            "yaml.load() can be unsafe if used on untrusted input. Use yaml.safe_load() unless you fully trust the input.",
            "high",
            ["CWE-502"],
            ["a08_software_and_data_integrity_failures"],
            "Injection & Unsafe Calls",
            "Unsafe YAML deserialization",
        ),
        (
            r"\beval\(",
            "Use of eval() detected. If fed untrusted input, this can lead to code execution. Prefer safe parsing/dispatch.",
            "critical",
            ["CWE-94"],
            ["a03_injection"],
            "Injection & Unsafe Calls",
            "Code execution via eval",
        ),
    ]

    for pattern, message, severity, cwes, owasp_tags, category, title in deser_patterns:
        for match in re.finditer(pattern, code, re.IGNORECASE):
            snippet = match.group(0)
            vulnerabilities.append({
                "type": "deserialization_vulnerability",
                "title": title,
                "description": message,
                "category": category,
                "severity": severity,
                "line": code[:match.start()].count("\n") + 1,
                "code_snippet": snippet[:200],
                "cwe": cwes,
                "owasp_top_10_2021": owasp_tags,
            })

    return vulnerabilities


def _scan_vulnerable_components(code: str, language: str) -> List[Dict[str, Any]]:
    """
    Scan for vulnerable components / risky dependency usage indicators (OWASP A06).

    NOTE:
    - Detecting exact vulnerable versions from source code is unreliable.
    - Use dependency scanners (pip-audit, npm audit, Snyk) for real CVE/version detection.
    - This function focuses on high-signal insecure usage patterns visible in code.
    """
    vulnerabilities: List[Dict[str, Any]] = []

    patterns = [
        (
            r"\burllib3\.disable_warnings\(",
            "urllib3 warnings are disabled. This can hide TLS/certificate validation problems and security issues.",
            "medium",
            ["CWE-693"],
            ["a06_vulnerable_and_outdated_components"],
            "Dependencies & Libraries",
            "Security warnings disabled (urllib3)",
        ),
        (
            r"\brequests\.get\([^)]*verify\s*=\s*False",
            "requests verification is disabled (verify=False). This can enable MITM attacks.",
            "high",
            ["CWE-295"],
            ["a02_cryptographic_failures"],
            "Data Protection",
            "TLS verification disabled (requests)",
        ),
    ]

    for pattern, message, severity, cwes, owasp_tags, category, title in patterns:
        for match in re.finditer(pattern, code, re.IGNORECASE):
            snippet = match.group(0)
            vulnerabilities.append({
                "type": "vulnerable_component",
                "title": title,
                "description": message,
                "category": category,
                "severity": severity,
                "line": code[:match.start()].count("\n") + 1,
                "code_snippet": snippet[:200],
                "cwe": cwes,
                "owasp_top_10_2021": owasp_tags,
            })

    return vulnerabilities


def _scan_logging_issues(code: str, language: str) -> List[Dict[str, Any]]:
    """
    Scan for insufficient logging/monitoring signals (OWASP A09).

    NOTE:
    This is heuristic. Improved to check for actual authentication/authorization CODE PATTERNS
    rather than just keyword presence in comments/docstrings.
    Only emit findings when substantive auth code exists without corresponding security logging.
    """
    vulnerabilities: List[Dict[str, Any]] = []

    # Check for actual authentication/authorization code patterns (not just keywords in comments)
    auth_code_patterns = [
        r"\bdef\s+\w*(login|authenticate|auth|verify_token|check_permission|authorize)\w*\s*\(",  # Function definitions
        r"@\w*\.(route|post|get|put|delete)\s*\([^)]*\/(login|auth|token|verify)",  # Auth endpoints
        r"\bjwt\.(encode|decode)\s*\(",  # JWT operations
        r"\.verify_password\s*\(",  # Password verification
        r"session\[\s*['\"]user['\"]|request\.user|current_user",  # Session/user access
        r"@(login_required|require_auth|authenticated|permission_required)",  # Auth decorators
    ]
    
    has_auth_code = False
    for pattern in auth_code_patterns:
        if re.search(pattern, code, re.IGNORECASE):
            has_auth_code = True
            break
    
    # Check for security-relevant logging patterns
    has_security_logging = bool(re.search(
        r"\b(log|logger)\.\w+\([^)]*(security|auth|login|token|permission|denied|failed|unauthorized)[^)]*\)", 
        code, 
        re.IGNORECASE
    ))

    if has_auth_code and not has_security_logging:
        vulnerabilities.append({
            "type": "insufficient_logging",
            "title": "Insufficient security logging (heuristic)",
            "description": "Authentication/authorization code detected (function definitions, endpoints, or decorators), but no clear security-relevant logging was found. Consider adding audit/security logs for auth events (login failures, token validation failures, permission denials).",
            "category": "Error Handling & Logging",
            "severity": "medium",
            "line": 1,
            "code_snippet": "No explicit security/auth logging pattern detected (heuristic).",
            "cwe": ["CWE-778"],
            "owasp_top_10_2021": ["a09_security_logging_and_monitoring_failures"],
        })

    return vulnerabilities


def _assess_security_risk(
    code: str,
    language: str,
    vulnerabilities: Optional[List[Dict[str, Any]]] = None,
) -> Dict[str, Any]:
    """
    Assess overall security risk level.

    Preferred: compute from detected vulnerabilities (more reliable than regex heuristics).
    Fallback: minimal heuristics if vulnerabilities not provided.
    """
    # ---------------------------
    # Preferred path: findings-based
    # ---------------------------
    if isinstance(vulnerabilities, list) and vulnerabilities:
        counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}

        for v in vulnerabilities:
            if not isinstance(v, dict):
                continue
            sev = (v.get("severity") or "low").lower()
            if sev in counts:
                counts[sev] += 1

        # Weighted score
        risk_score = (
            counts["critical"] * 5
            + counts["high"] * 3
            + counts["medium"] * 2
            + counts["low"] * 1
        )

        if risk_score >= 15:
            risk_level = "critical"
        elif risk_score >= 8:
            risk_level = "high"
        elif risk_score >= 3:
            risk_level = "medium"
        else:
            risk_level = "low"

        return {
            "overall_risk_level": risk_level,
            "risk_score": risk_score,
            "risk_factors": {
                "by_severity": counts,
                "note": "Risk computed from detected findings (preferred).",
            },
            "security_grade": _get_security_grade(risk_score),
        }

    # ---------------------------
    # Fallback path: minimal heuristics
    # (kept intentionally conservative)
    # ---------------------------
    risk_factors = {
        "xss_risk": len(re.findall(r"\b(innerHTML|document\.write)\b", code, re.IGNORECASE)),
        "auth_bypass_risk": len(re.findall(r"\b(verify\s*=\s*False|ssl_verify\s*=\s*False)\b", code, re.IGNORECASE)),
        "code_execution_risk": len(re.findall(r"\b(eval\(|exec\(|os\.system)\b", code, re.IGNORECASE)),
        "secret_exposure_risk": len(re.findall(r"\b(password|api_key|secret|token)\b", code, re.IGNORECASE)),
    }

    total_risk_score = sum(risk_factors.values())

    if total_risk_score >= 10:
        risk_level = "critical"
    elif total_risk_score >= 5:
        risk_level = "high"
    elif total_risk_score >= 2:
        risk_level = "medium"
    else:
        risk_level = "low"

    return {
        "overall_risk_level": risk_level,
        "risk_score": total_risk_score,
        "risk_factors": risk_factors,
        "security_grade": _get_security_grade(total_risk_score),
    }


def _check_security_compliance(code: str, language: str) -> Dict[str, Any]:
    """
    Check compliance signals with common security practices.
    These are indicators only (static analysis cannot guarantee compliance).
    """
    return {
        "owasp_compliance": "unknown",  # static scan can't assert compliance
        "pci_dss_indicators": _check_pci_compliance(code),
        "gdpr_indicators": _check_gdpr_compliance(code),
        "security_headers": _check_security_headers(code),
        "input_validation": _check_input_validation(code),
        "notes": [
            "These are static indicators only; run SAST/DAST and dependency scanning for stronger assurance."
        ],
    }


def _check_pci_compliance(code: str) -> List[str]:
    """Check for PCI DSS compliance indicators (signal only)."""
    indicators = []
    low = code.lower()
    if any(k in low for k in ["credit_card", "card_number", "cc_number", "pan"]):
        indicators.append("Payment card data handling detected")
    if "encrypt" in low or "cipher" in low or "tls" in low:
        indicators.append("Encryption/TLS usage signal detected")
    return indicators


def _check_gdpr_compliance(code: str) -> List[str]:
    """Check for GDPR-related indicators (signal only)."""
    indicators = []
    low = code.lower()
    if any(k in low for k in ["personal_data", "user_data", "pii", "email", "address", "dob"]):
        indicators.append("Personal data processing signal detected")
    if "consent" in low:
        indicators.append("Consent handling signal detected")
    return indicators


def _check_security_headers(code: str) -> List[str]:
    """Check for security headers implementation."""
    headers = []
    if 'X-Frame-Options' in code:
        headers.append('X-Frame-Options header found')
    if 'Content-Security-Policy' in code:
        headers.append('CSP header found')
    return headers


def _check_input_validation(code: str) -> bool:
    """Check if input validation/sanitization signals are present (heuristic)."""
    validation_patterns = [
        r"\bvalidate\(",
        r"\bsanitize\(",
        r"\bescape\(",
        r"\bhtml\.escape\(",
        r"\bbleach\.clean\(",
        r"\bpydantic\b",
        r"\bmarshmallow\b",
        r"\bcerberus\b",
        r"\bjsonschema\b",
    ]

    for pattern in validation_patterns:
        if re.search(pattern, code, re.IGNORECASE):
            return True
    return False


def _get_security_grade(risk_score: int) -> str:
    """Get security grade based on risk score."""
    if risk_score == 0:
        return 'A'
    elif risk_score <= 2:
        return 'B'
    elif risk_score <= 5:
        return 'C'
    elif risk_score <= 10:
        return 'D'
    else:
        return 'F'


def _generate_security_recommendations(
    code: str,
    language: str,
    vulnerabilities: Optional[List[Dict[str, Any]]] = None
) -> List[str]:
    """
    Generate recommendations.
    Prefer deriving recommendations from detected vulnerabilities (more reliable than regex heuristics).
    """
    recommendations: List[str] = []

    # --- Preferred path: based on findings ---
    if isinstance(vulnerabilities, list) and vulnerabilities:
        # Collect categories/types present
        cats = {str(v.get("category", "")).strip() for v in vulnerabilities if isinstance(v, dict)}
        types = {str(v.get("type", "")).strip() for v in vulnerabilities if isinstance(v, dict)}
        cwes = set()
        for v in vulnerabilities:
            if isinstance(v, dict):
                for c in (v.get("cwe") or []):
                    cwes.add(str(c))

        # Map signals -> recommendations (deterministic)
        if "Injection & Unsafe Calls" in cats or "xss_vulnerability" in types or "injection_vulnerability" in types:
            recommendations.append("Use parameterized queries / safe APIs; avoid string concatenation for SQL/shell/HTML.")

        if "Secrets Management" in cats or any("CWE-798" in c for c in cwes):
            recommendations.append("Move secrets to a secret manager or environment variables; rotate exposed credentials.")

        if "Authentication & Authorization" in cats:
            recommendations.append("Ensure all protected endpoints enforce authentication and authorization checks consistently.")

        if any("CWE-295" in c for c in cwes):
            recommendations.append("Enable TLS certificate verification and avoid disabling verification in production.")

        if any("CWE-94" in c for c in cwes) or "deserialization_vulnerability" in types:
            recommendations.append("Avoid eval/exec and unsafe deserialization (pickle/yaml.load); use safe alternatives and strict input validation.")

        if "Error Handling & Logging" in cats:
            recommendations.append("Add security-relevant audit logging for auth failures, permission denials, and suspicious activity (without secrets).")

        # Always ensure at least one recommendation when findings exist
        if not recommendations:
            recommendations.append("Review findings and apply targeted mitigations; prioritize high/critical issues first.")

        return recommendations

    # --- Fallback path: light heuristics (keep minimal, avoid the old SQL '%' rule) ---
    low = code.lower()

    if "password" in low:
        recommendations.append("Use secure password hashing (bcrypt, scrypt, or Argon2).")
        recommendations.append("Store sensitive data in environment variables or a secret manager.")

    if "api_key" in low or "secret" in low or "token" in low:
        recommendations.append("Use environment variables/secret manager for secrets; rotate if exposed.")

    if "eval(" in code or "exec(" in code:
        recommendations.append("Avoid using eval() and exec(); use safer parsing/dispatch patterns.")

    if "ssl_verify=false" in low or "verify=false" in low:
        recommendations.append("Enable TLS certificate verification (avoid verify=False / ssl_verify=False).")

    if not re.search(r"\blog\.\w+\([^)]*(security|auth|login|token)[^)]*\)", code, re.IGNORECASE):
        if "login" in low or "auth" in low:
            recommendations.append("Implement security event logging for authentication/authorization flows (without secrets).")

    if not recommendations:
        recommendations.append("No critical security issues detected - maintain current security practices.")

    return recommendations